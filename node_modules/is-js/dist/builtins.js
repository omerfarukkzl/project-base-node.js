"use strict";
// User defined type guards for native Javascript objects
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.promiseLike = exports.promise = exports.regex = exports.error = exports.func = exports.date = exports.array = exports.object = void 0;
const toString = Object.prototype.toString;
/**
 * Determines if the argument is an object.
 *
 * @remarks
 * Nearly everything in Javascript is an object; this method discerns between
 * native primitives (e.g. `true`, `3`, `some text`) and their object-wrapped
 * variants (Boolean, Number, String)
 *
 * @param value - Value in question
 * @returns `true` if the given argument is an object
 */
function object(value) {
    return value === Object(value);
}
exports.object = object;
/**
 * Determines if the argument is an array.
 *
 * @remarks
 * Defaults to the native `Array.isArray` method, if present.
 *
 * @param value - Value in question
 * @returns `true` if the given argument is an array
 */
exports.array = (_a = Array.isArray) !== null && _a !== void 0 ? _a : ((value) => toString.call(value) === "[object Array]");
/**
 * Determines if the argument is a date.
 *
 * @param value - Value in question
 * @returns `true` if the given argument is a date
 */
function date(value) {
    return value ? value.constructor === Date : false;
}
exports.date = date;
/**
 * Determines if the argument is a function.
 *
 * @param value - Value in question
 * @returns `true` if the given argument is a function
 */
function func(value) {
    return typeof value === "function";
}
exports.func = func;
/**
 * Determines if the argument is an error.
 *
 * @param value - Value in question
 * @returns `true` if the given argument is an error
 */
function error(value) {
    return value instanceof Error;
}
exports.error = error;
/**
 * Determines if the argument is a regular expression.
 *
 * @param value - Value in question
 * @returns `true` if the given argument is a regular expression
 */
function regex(value) {
    return value ? value.constructor === RegExp : false;
}
exports.regex = regex;
/**
 * Determines if the argument is a native promise.
 *
 * @remarks
 * Some libraries and frameworks still include their own polyfilled Promises,
 * in which case this method is unreliable. If you are using such a library,
 * please defer to the provided Promise implementation or use {@link promiseLike}
 *
 * @param value - Value in question
 * @returns `true` if the given argument is a string
 */
function promise(value) {
    return value ? value.constructor === Promise : false;
}
exports.promise = promise;
/**
 * Determines if the argument conforms to the minimal interface of a Promise;
 * that is, it has a method named `then`.
 *
 * @param value - Value in question
 * @returns `true` if the given argument conforms to the Promise interface
 */
function promiseLike(value) {
    return value ? func(value.then) : false;
}
exports.promiseLike = promiseLike;
